package p1;

import java.util.*;

public class Arrays {
	
	public static void easyProblems(int[] nums, int option) {
		if(option == 1) {
			int maxi = 0;
			for(int i = 0; i < nums.length; i++) {
				if(nums[i] > maxi) {
					maxi = nums[i];
				}
			}
			System.out.println("Maximum number: "+ maxi);
		} else if (option == 2) {
			int min = Integer.MAX_VALUE;
			int max = Integer.MIN_VALUE;
			for(int i =0; i < nums.length; i++) {
				if(nums[i] < min) {
					min = nums[i];
				} if(nums[i] > max) {
					max = nums[i];
				}
			}
			System.out.println("The second smallest number is: " + min);
			System.out.println("The second largest number is: " + max);
		} else if (option == 3) {
			for(int i = 1; i < nums.length; i++) {
				if(nums[i-1] > nums[i]) {
					System.out.println("This is not a sorted array");
					break;
				}
			}
			System.out.println("This is a sorted array");
		} else if(option == 4) {
//			LEFT ROTATION:
//				reverse(0 → k-1)
//				reverse(k → n-1)
//				reverse(0 → n-1)
//
//			RIGHT ROTATION:
//				reverse(0 → n-1)
//				reverse(0 → k-1)
//				reverse(k → n-1)
			
			
			int k = 1;
			
				// okay so let's get into thinking so left rotation requires swapping continuous swapping until first element reaches last element
				// this is confusing every time .. actually this one need swapping definitely
				// you can remember this pattern -> just reverse the elements , 0 -> k-1, k -> n-1, 0-> n-1
				
			reverse(0, k-1, nums);
			reverse(k, nums.length - 1, nums);
			reverse(0, nums.length - 1, nums);
			
			// 0 -> k-1, k -> n-1, 0-> n-1 here you are just reversing the entire array in 2 parts(first half - starting(0) -> k-1, next second half - k -> n-1, then reversing entire array
			
			for(int ele: nums) {
				System.out.print(ele+ " ");
			}
		}
	}
	
	public static void reverse(int start, int end, int[] arr) {
		while(start < end) {
			int temp = arr[start];
			arr[start] = arr[end];
			arr[end] = temp;
			start++;
			end--;
		}
	}
	
	public static void moveAllZeroes(int[] nums) {
		// I am thinking of 1 approach here -> store the zeroes in Treemap not hashmap, In treemap 
		// the elements can be stored in the relative order
//		Map<Integer, Integer> treemap = new TreeMap<>();
//		
//		for(int i = 0; i < nums.length; i++) {
//			if(treemap.containsKey(nums[i])) {
//				treemap.put(nums[i], treemap.get(nums[i]) + 1);
//			} else {
//				treemap.put(nums[i], 1);
//			}
//		}
//		int index = 0;
//		for(Map.Entry<Integer, Integer> entry : treemap.entrySet()) {
//			int key = entry.getKey();
//			int value = entry.getValue();
//			
//			
//			if(key!= 0) {
//				while(value >= 1) {
//					nums[index] = key;
//					value--; //oops this is blunder this block we should not use the relative order fails here itself only
//					// actually this concept works on non duplicate elements otherwise it fails.
//				}
//			}
//			index++;
//		}
//		
//		for(int i = index; i < nums.length; i++) {
//			nums[i] = 0;
//		}
//		
		// You have to use two pointers for this -> move zeroes
		
		// If a problem says “maintain relative order”,
		
		// -> use Two pointers since Map just takes the space O(N), and two pointers is O(1)
		
		int right = 0;
		for(int left = 0; left < nums.length; left++) {
			if(nums[left] != 0) {
				nums[right++] = nums[left];
			}
		}
		
		for(int i = right; i < nums.length; i++) {
			nums[right++] = 0;
		}
		
		for(int i = 0; i < nums.length; i++) {
			System.out.print(nums[i] + " ");
		}
		
	}
	
	public static void findUnion(int[] num1, int[] num2) {
		// so obviously this num1, num2 - we need to find distinct elements and common elements with sizes of n and m
		
		// I can use LinkedHashMap for maintaining sorting order so the constraint should be on returning common & distinct elements in the sorting order
		
		Map<Integer, Integer> sortedOrder = new LinkedHashMap<>();
		
		String maxlen = (num1.length > num2.length) ? "num1" : "num2";
		
	//	if(maxlen == "num1") { // this string comparison is unsafe in java I should use .equals() probably
			
			for(int i = 0; i < num1.length; i++) {
				if(sortedOrder.containsKey(num1[i])) {
					sortedOrder.put(num1[i], sortedOrder.get(num1[i]) + 1);
				} else {
					sortedOrder.put(num1[i], 1);
				}
			}
	
			for(int i = 0; i < num2.length; i++) {
				if(sortedOrder.containsKey(num2[i])) {
					sortedOrder.put(num2[i], sortedOrder.get(num2[i]) + 1);
				} else {
					sortedOrder.put(num2[i], 1);
				}
			}
		
		for(Map.Entry<Integer, Integer> entry : sortedOrder.entrySet()) {
			System.out.print(entry.getKey() + " ");
		}
		// Now This will print the both common and distinct elements
		
		// but the optimal solution for this using Set, since set will not allow duplicates..
		
		// only union -> Set, union + order -> LinkedHashSet, union + sorted -> TreeSet
		
	}

	public static void main(String[] args) {
		// TODO Auto-generated method stub
//		Scanner sc = new Scanner(System.in);
//		
//		int[] nums = {1, 2, 3, 4, 5};
//		
//		int option = sc.nextInt();
//		
//		easyProblems(nums, option);
		
		int[] nums = {1 ,0 ,2 ,3 ,0 ,4 ,0 ,1};
		
		moveAllZeroes(nums);
		
		int[] num1 = {1,2,3,4,5};
		int[] num2 = {2,3,4,4,5};
		
		findUnion(num1, num2); 

	}

}
