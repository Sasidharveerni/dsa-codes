package p1;

import java.util.Arrays;
import java.util.*;

public class Sorting {
	
	public static void bubbleSort(int[] nums) {
		for(int i = nums.length - 1; i >= 0; i--) {
			boolean swapped = false;
			for(int j = 0; j < i; j++) {
				if(nums[j] > nums[j + 1]) {
					int temp = nums[j];
					nums[j] = nums[j + 1];
					nums[j + 1] = temp;
					swapped = true;
				}
			}
			if(swapped) break;
		}
		
	    for(int i = 0; i < nums.length; i++) {
        	
//        	System.out.print(nums[i] + ' '); ' ' is a char literal (ASCII 32).
//        	So it actually prints numbers like (num + 32) (e.g. 3 becomes 35).
	    	System.out.print(nums[i] + " ");
        }
	}

	public static void selectionSort(int[] nums) {
		// sorting : Sorting is simple it is always O(n^2) in most of the cases, in some cases
		// it would be O(nlogn). Okay but always remember one thing the way of sorting is important.
		// that's why several algorithms were introduced. 
		
		// Selection Sort: 
		
		
//		int min = nums[0]; // It will not work my brother since I need indexes not the value
//		for(int i = 0; i < nums.length - 1; i++) {
//			for(int j = i + 1; j < nums.length; j++) {
//				if(nums[j] < min) {
//					min = nums[j];
//				}
//			}
//			int temp = nums[i];
//			nums[i] = min;
//			min = temp; // here, the swapping made senseless even though min = temp at new iteration it will be min = nums[i]
//			
//			// and it always be smallest number for multiple iterations you are essentially swapping all the numbers with minimum a smallest number
//			// our goal is to find the smallest number in the inner loop
//			
//		}
		
		for(int i = 0; i < nums.length - 1; i++) {
			int minIndex = i;
			for(int j = i + 1; j < nums.length; j++) {
				if(nums[j] < nums[minIndex]) {
					minIndex = j;
				}
			}
			int temp = nums[i];
			nums[i] = nums[minIndex];
			nums[minIndex] = temp;
		}
		
		for(int i = 0; i < nums.length; i++) {
			System.out.print(nums[i] + " "); // TC: O(n^2) for sorted arrays also
		}
	}
	
	public static void insertionSort(int[] nums) {
		// here also swapping involved,
		
		for(int i = 0; i < nums.length; i++) {
			int j = i;
			//int minIndex = i;
			while(j > 0 && nums[j] < nums[j - 1]) {
				
					int temp = nums[j-1];
					nums[j-1] = nums[j];
					nums[j] = temp;
					j--;
				
			}
			
		}
		
		for(int i = 0; i < nums.length; i++) {
			System.out.print(nums[i] + " ");
		}
	}
	
	
	public static int[] mergeSort(int[] nums) {
		// Merge Sorting Idea : The idea is to use divide and conquer algorithm, First divide your array into 2 halves
		//So now think of 2 halves left, right - now you need to divide left half to 2 halves again, again that left half - 2 halves ..., until you reach 1 or 2 elements 
		// now sort that elements by comparing if you have 2 elements - now after sorting done merge it back again compare and merge 
		
		if(nums.length <= 1) return nums;
		
		int mid = nums.length / 2;
		
		//  int[] slicedArray = Arrays.copyOfRange(originalArray, startIndex, endIndex);
		
		int[] leftHalf = Arrays.copyOfRange(nums, 0, mid);
		
		
		int[] rightHalf = Arrays.copyOfRange(nums, mid, nums.length );
		
		
		
		int[] sortedLeft = mergeSort(leftHalf);
		
		int[] sortedRight = mergeSort(rightHalf);
		
		return merge(sortedLeft, sortedRight);
		
	}
	
	public static int[] merge(int[] left, int[] right) {
		int[] result = new int[left.length + right.length];
		
		int i = 0, j = 0, k = 0;
		
		while(i < left.length && j < right.length) {
			if(left[i] < right[j]) {
				result[k] = left[i];
				i++;
			} else {
				result[k] =  right[j];
				j++;
			}
			k++;
		}
		
		while(i < left.length) {
				result[k] = left[i];
				i++;
				k++;
			
		} while(j < right.length) {
			result[k] =  right[j];
			j++;
			k++;
		}
		
		return result;
		
	}
	
//	1. Sort by Frequency (Custom Comparator)
//
//	Given an array of integers, sort them by frequency (highest first).
//	If two numbers have the same frequency, sort by value ascending.
//	Example:
//	Input â†’ [4,4,1,2,2,3,3,3]
//	Output â†’ [3,3,3,4,4,2,2,1]
//
//	ðŸ§© Concepts: HashMap + Comparator sorting (value-based sorting).
	
	public static void sortFrequency(int[] nums) {
		// since it is a value based sorting I prefer to use insertion sorting 
		
		Map<Integer, Integer> map = new HashMap<>();
		for(int i = 0; i < nums.length; i++) {
			if(map.containsKey(nums[i])) {
				map.put(nums[i], map.get(nums[i]) + 1);
			} else {
				map.put(nums[i],  1);
			}
		}
		
		// now I understand the problem I need to sort them by frequency - this is one kind of sorting
		
	// any way the relative order way of storing is in sorted order for hashmaps 
		// âš ï¸ Slight correction â€”
//		HashMap in Java does not preserve any order (neither insertion nor sorted).
//		If you want ordering:
//
//		Use LinkedHashMap (preserves insertion order).
//
//		Or TreeMap (keeps keys sorted).
//		But for frequency sorting, youâ€™ll usually use a List<Map.Entry<...>> â†’ then apply sorting manually.
		// but to sort frequency wise we must scan entire hash map - we should need one sorting algorithm
		
		// so I'm gonna use insertion sort
		
		
		
		for(int i = 0; i < nums.length; i++) {
			int j = i;
			while(j > 0 && map.get(nums[j]) > map.get(nums[j - 1])) {
				int temp = nums[j - 1];
				nums[j - 1] = nums[j];
				nums[j] = temp;
				j--;
			}
		}
		
		for(int i = 0; i < nums.length; i++) {
			System.out.print(nums[i] + " ");
		}
		
//		for(Map.Entry<Integer, Integer> entry : map.entrySet()) {
//			Integer Key = entry.getKey();
//			Integer Value = entry.getValue();
//			
//			int i = 0;
//			
//			int j = i;
//			
//			while(j > 0 && nums[j] < nums[j])
//			
//			System.out.print(Key + ":" + Value + " ");
//			
//		}
		
//		for(int i = 0; i < nums.length; i++) {
//			int j = i;
//			while(j > 0 && nums[j] < nums[j - 1]) { // this condition is very important
//				
//				 int temp = nums[j - 1];
//					nums[j - 1] = nums[j];
//					nums[j] = temp;
//				j--; // this one is also - for selection sort
//			}
//			
//		}
//		
//		for(int i = 0; i < nums.length; i++) {
//			System.out.print(nums[i] + " ");
//		}
	}
	
// 2.	Sort 0s, 1s, and 2s (Dutch National Flag Problem)
//
//	Given an array with only 0s, 1s, 2s â†’ sort them in-place without using built-in sort.
//	Example:
//	Input â†’ [2,0,2,1,1,0]
//	Output â†’ [0,0,1,1,2,2]
//
//	ðŸ§© Concepts: In-place partitioning, pointer-based sorting.
	
	public static int[] sortZeroOneTwos(int[] nums) {
		
		// shit , I forgot to add base condition
		if(nums.length <= 1) return nums;
		// so I can directly use sorting algorithm ?? I'll use merge sort since it's optimal
		
		// so what I need to make is recursive calls
		
		int mid = nums.length / 2;
		
		int[] leftHalf = Arrays.copyOfRange(nums, 0, mid);
		int[] rightHalf = Arrays.copyOfRange(nums, mid , nums.length);
		
		int[]left = sortZeroOneTwos(leftHalf);
		int[] right = sortZeroOneTwos(rightHalf);
		
		return merge(left, right);
	}
	
//	Sort Characters by Frequency (String-based)
//
//	Sort characters in a string by descending frequency.
//	Example:
//	Input â†’ "tree"
//	Output â†’ "eetr" or "eert"
//
//	ðŸ§© Concepts: Counting frequency + sorting map entries.
	
	public static void sortStringFrequency(String val) {
		Map<Character, Integer> map = new HashMap<>();
		
		for(int i = 0; i < val.length(); i++) {
			if(map.containsKey(val.charAt(i))) {
				map.put(val.charAt(i), map.get(val.charAt(i)) + 1);
			} else {
				map.put(val.charAt(i), 1);
			}
		}
		
		// we cannot use insertion sort bcoz insertion sort focuses on inplace sorting
		// but strings are immutable so can't use insertion sort for strings
		// but we can use string builder for string manipulation
		
		StringBuilder res = new StringBuilder(val);
		for(int i = 0; i < val.length(); i++) {
			int j = i;
			while(j > 0 && map.get(res.charAt(j)) > map.get(res.charAt(j - 1))) {
//				 String str = String.valueOf(res.charAt(j));
				char temp = res.charAt(j - 1);
				res.setCharAt(j - 1, res.charAt(j)); 
				res.setCharAt(j, temp);
				
				
				 // here I am struck at how to replace the string values just like nums
				 j--;
				// System.out.print(res+ " ");
				
			}
		}
		System.out.print(res + " ");
		
	}
	
//	4. Merge Overlapping Intervals
//
//	Given intervals [[1,3],[2,6],[8,10],[15,18]], merge overlapping ones.
//	Example:
//	Output â†’ [[1,6],[8,10],[15,18]]
//
//	ðŸ§© Concepts: Sort by start time â†’ then linear merge pass.
	
	// this I will attempt later 
	
//	5. Sort People by Height (Parallel Arrays / Pair Sorting)
//
//	You have 2 arrays â€” names[] and heights[].
//	Sort names by height descending.
//	Example:
//	Input â†’
//	names = ["Mary","John","Emma"]
//	heights = [180,165,170]
//	Output â†’ ["Mary","Emma","John"]
//
//	ðŸ§© Concepts: Pair sorting using custom comparator.
	
	// I am considering that both names and heights are same length so I can use one sorting algorithm directly.
	
	// always use insertion sort algorithm for in-place sorting algorithm, 
	
	// but we cannot use  merge sort -> since the comparision between two halves we cannot decide at how to allocate other names array which is string
	
	
		
	
	public static void sortPeopleHeight(int[] heights, String[] names, int cases) {
		
	if(cases == 1) {
		
		for(int i = 0; i < heights.length; i++) {
			int j = i;
			while(j > 0 && heights[j] > heights[j-1]) {
				String temp = names[j-1];
				names[j-1] = names[j];
				names[j] = temp;
				j--;
			}
			
		}
		for(int i = 0; i < names.length; i++) {
			System.out.print(names[i] + " ");
		}
	} else {
		
		
		// Should add any other sorting technique
		
		
	}
		
		
	}
	
	public static void main(String[] args) {
		// TODO Auto-generated method stub
      //  int[] nums = {3, 4, 1, 9, 5, 4};
		int[] nums = {2,0,2,1,1,0};
      // bubbleSort(nums);
//        for(int i = 0; i < val.length; i++) {
//        	
//        	System.out.print(val[i] + ' ');
//        }
       //selectionSort(nums);
        
      //  insertionSort(nums);
        
    //   int[] res = mergeSort(nums);
       
//       int mid = nums.length / 2;
//       
//       
//       
//       int[] leftHalf = Arrays.copyOfRange(nums, 0, mid);
//		
//		for(int i = 0; i < leftHalf.length; i++) {
//			System.out.print(leftHalf[i] + " ");
//			
//		}
//		System.out.println();
//		
//		int[] rightHalf = Arrays.copyOfRange(nums, mid, nums.length );
//		
//		for(int i = 0; i < rightHalf.length; i++) {
//			System.out.print(rightHalf[i] + " ");
//		}
       
     
//       int res[] = {4,4,1,2,2,3,3,3};
//       sortFrequency(res);
       
//       for(int i = 0; i < res.length; i++) {
//    	   System.out.print(res[i] + " ");
//       }
//        
//		int[] res = sortZeroOneTwos(nums);
//		for(int i = 0; i < res.length; i++) {
//			System.out.print(res[i] + " ");
//		}
		
//		String val = "tree";
//		sortStringFrequency(val);
		
		int[] heights = {180, 165, 170};
		String[] names = {"Mary","John","Emma"};
		Scanner scanner = new Scanner(System.in);
		int cases = scanner.nextInt();
		sortPeopleHeight(heights, names, cases);
	}

}
